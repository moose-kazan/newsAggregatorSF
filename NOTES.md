Получение новости и комментариев к ней в одном запросе
КМК так себе идея. Понятно что в учебном проекте это
позволит продемонстрировать умение писать асинхронный код,
однако в реальной жизни возможно стоит переложить это на
фронтед.

Если фронтенд сам будет асинхронно запрашивать новость и
комментарии к ней то для постраничной навигации по
комментариям не придётся писать дополнительный вызов
или дёргать новую страницу вместе с повторным получением
текста новости.

Ещё предлагается использовать канал для получения данных
от гороутин в асинхронном запросе. КМК это было бы оправдано
в случае большого и/или переменного количества параллельных
запросов. В случае когда их всего два и только два вполне
достаточно двух отдельных переменных.

Если же требуется продемонстировать умение работать с
каналами то это умение итак демонстрируется в сервисе
новостей;-)

Использовать http для обращения к микросервисам можно, но
ИМХО лучше что-то вроде GRPC, ибо у http КМК слишком
много лишнего.

Раз уж используем http, то request_id стоит пихать в
заголовки. Не знаю кто как, а мы на своих проектах
уже много лет именно так и делаем.

Поиск. Тут была фантазия прикрутить sphinxsearch, но в силу
ограниченности ресурсов (в основном времени) пришлось
отказаться от такой хорошей идеи и тупо заюзать ILIKE.

Пагинация: в MySQL есть офигенное решение для этого:
SQL_CALC_FOUND_ROWS / SELECT FOUND_ROWS(). В Postgre внятного
аналога не нашёл. Пришлось делать не так изящно. (см
PostSearch в serviceNews/internal/dbaccess/).

Фронтенд: первый раз в жизни использовал Vue, и вообще первый
раз использовал JS-фреймворк. Результат самому себе противен,
но каким-то странным образом он даже работает, не смотря на
всю его кривизну.

Логи: по уму их надо кидать в syslog/ELK/something else, но
опять же ограниченность по времени побуждает вываливать на
stdout/stderr. Нормальные DevOps умеют собирать этот поток
демонского сознания через logstash. Так что особой
проблемы тут я не вижу.

По условиям задачи сервис модерации должен возвращть 200
если комментарий "чист" и 400 если нет. КМК в обоих случаях
надо 200 и результат проверки в теле ответа, но раз в ТЗ
просят - сделаем. Хотя для этого и пришлось запилить в
gateway/internal/api костыль в виде LastCode()

Баги: то что было на виду - вычищено. Однако не сомневаюсь что
они есть.

Очерёдность запуска сервисов выстроена через depends_on в
docker-compose.yml, но этого оказалось недостаточно:
контейнер с postgres считается запущенным сразу как процесс
ушёл в фон, хотя к тому моменту он не готов обрабатывать
запросы.

Костыли с netcat и pg_isready в целом решают проблему, однако
при самом первом запуске контейнера postgres запускается,
создаётся БД и юзер, postgre перезапускается. Из-за этого
на медленных системах возможны ошибки при первом запуске
приложения.

Загрузка схем БД и списка источников выполняется в
run.sh-скриптых сервисов. Чтобы не начинать жизнь с нуля при
каждом перезапуске приложения БД лежит на внешнем томе, и
так же на внешнем томе лежат файлы-флаги, при наличии
которых повторная загрузка схем производиться не будет.)
